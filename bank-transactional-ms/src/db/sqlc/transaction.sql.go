// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const findByAccountIdAndTransactionId = `-- name: FindByAccountIdAndTransactionId :one
select transaction.transaction_uuid, transaction.account_uuid, transaction.provider_account_id, transaction.description, transaction.description_type, transaction.identification, transaction.status, transaction.amount, transaction.currency, transaction.date_time, transaction.created_at
 from transaction as transaction
where transaction.account_uuid = $1
  and transaction.transaction_uuid = $2
`

type FindByAccountIdAndTransactionIdParams struct {
	AccountUuid     uuid.UUID `json:"account_uuid"`
	TransactionUuid uuid.UUID `json:"transaction_uuid"`
}

func (q *Queries) FindByAccountIdAndTransactionId(ctx context.Context, arg FindByAccountIdAndTransactionIdParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, findByAccountIdAndTransactionId, arg.AccountUuid, arg.TransactionUuid)
	var i Transaction
	err := row.Scan(
		&i.TransactionUuid,
		&i.AccountUuid,
		&i.ProviderAccountID,
		&i.Description,
		&i.DescriptionType,
		&i.Identification,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.DateTime,
		&i.CreatedAt,
	)
	return i, err
}

const findTransactionsByAccount = `-- name: FindTransactionsByAccount :many
  select transaction.transaction_uuid, transaction.account_uuid, transaction.provider_account_id, transaction.description, transaction.description_type, transaction.identification, transaction.status, transaction.amount, transaction.currency, transaction.date_time, transaction.created_at
    from transaction as transaction
   where transaction.account_uuid = $1
order by transaction.date_time desc
`

func (q *Queries) FindTransactionsByAccount(ctx context.Context, accountUuid uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, findTransactionsByAccount, accountUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionUuid,
			&i.AccountUuid,
			&i.ProviderAccountID,
			&i.Description,
			&i.DescriptionType,
			&i.Identification,
			&i.Status,
			&i.Amount,
			&i.Currency,
			&i.DateTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTransaction = `-- name: InsertTransaction :one
INSERT INTO transaction (account_uuid, provider_account_id, description,
                         description_type, identification, status, amount,
                         currency, date_time)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    RETURNING transaction_uuid, account_uuid, provider_account_id, description, description_type, identification, status, amount, currency, date_time, created_at
`

type InsertTransactionParams struct {
	AccountUuid       uuid.UUID      `json:"account_uuid"`
	ProviderAccountID string         `json:"provider_account_id"`
	Description       sql.NullString `json:"description"`
	DescriptionType   sql.NullString `json:"description_type"`
	Identification    string         `json:"identification"`
	Status            string         `json:"status"`
	Amount            float64        `json:"amount"`
	Currency          string         `json:"currency"`
	DateTime          time.Time      `json:"date_time"`
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, insertTransaction,
		arg.AccountUuid,
		arg.ProviderAccountID,
		arg.Description,
		arg.DescriptionType,
		arg.Identification,
		arg.Status,
		arg.Amount,
		arg.Currency,
		arg.DateTime,
	)
	var i Transaction
	err := row.Scan(
		&i.TransactionUuid,
		&i.AccountUuid,
		&i.ProviderAccountID,
		&i.Description,
		&i.DescriptionType,
		&i.Identification,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.DateTime,
		&i.CreatedAt,
	)
	return i, err
}
